#!/bin/bash

readonly rawman=${executive}.1.md
readonly color='\e[32m'
readonly reset='\e[0m'

_version()
{
		echo "$(basename $0) - version $VERSION"
}

_usage()
{
		_version
		echo "
		|Usage:
		|   $(basename $0) [Options]... [Command]
        |
		|Options:
		|   -h, --help     Show usage information
		|   -v, --version  Show version information
		|   -n, --name=    name of the new script
		|   
        |Commands:
        |   new   setup a new working directory
        |   del   delete all working files in directory
        |   make  "compile" all working files\
		" | cut -d "|" -f 2
}

# Return values handled
_exit() { [ "$QUIET" == "0" ] && echo "EXIT ${*}" && exit "$@"; }

# Setup a new working directory
_setup() 
{
		# Options to supply own name
		local options
		options=$(getopt -o 'n:' -l 'name=:' -n "" -- "$@")
		while true; do case "$1" in
				-n|--name=) executive="$2"; shift 2 ;;
				--) shift; break ;;
		esac done
	
		eval set -- "$options"
		[ $? -ne 0 ] && _exit 1
	
		{ echo -n "[NAME]: "; read executive; _setup || _exit 1; } 
	
		# Check if a working setup exists
		[[ -f functions && -f vars ]] && _exit 1

		# Set native files, give an apropriate version number, and open $executive in an editor
		touch functions vars ${executive} || _exit 1
		echo "readonly VERSION=1.0" > vars || _exit 1
		echo "#!/bin/bash" > ${executive} && chmod +x ${executive} || _exit 1
		${editor} ${executive}
}

# Remove all native files
_remove()
{
		_remove_all()
		{
				{ while read -r line; do rm $(cut -d " " -f 2); done < functions; }
				[[ $? -eq 0 ]] && { rm vars functions ${executive}; } || _exit 1
		}
		
		if [[ "$QUIET" == "0" ]]
		then
				# Confirmation required
				echo "CONFIRM [ y | n ]: "
				read conf

				[[ "$conf" == "n" || "N" || "no" || "NO" ]] && return 0
				[[ "$conf" == "y" || "Y" || "yes" || "YES" ]] && _remove_all || _exit 1
		else
				_remove_all || _exit 1
		fi
}

# Show variable information
_list_vars()
{
		#sed '/^\s*$/d'
		echo -e "${color}VARIABLES:${reset}"
		while read -r line
		do
				case $line in
						''|\#*) continue ;;
				esac
						echo "$(echo -e ${color} $(echo $line | cut -d "=" -f 1 | cut -d " " -f 2\
								) ${reset})$(echo $line | cut -d "=" -f 2 | sed 's/#.*//')"
		done < vars
}

# Show functions' "order of opertations"
_list_functions()
{
		echo -e "${color}FUNCTIONS:${reset}" && \
				while read -r line
				do 
						echo -e " ${color}(${n})${reset}\t$(echo $line | cut -d ' ' -f 2)";
						n=$(($n + 1))
				done < functions | sed '1 d' | sed '$ d'
}


# Native files merged
_vars()
{
		# Start if 'vars' exists
		cat $executive | head -n 1 > .vars && cat vars >> .vars || return 1
}

_functions()
{
		while read line
		do
				cat $(cut -d " " -f 2) > .funcs
		done < functions
		[ $? -ne 0 ] && { return 1; } ||  return 0
}


# Special files handled
self=$(basename $0)
_special()
{
		local found
		for found in ${all_files[@]}
		do
				case "$found" in
						"$rawman") rm "$rawman" || return 1 ;;
						#"$self" ) rm "$self" || return 1 ;;
				esac
		done
}

# Finish him
_sweep()
{
		cat .funcs >> .vars && rm .funcs
		sed -i '1,4 d' $executive
		cat $executive >> .vars && rm $executive
		mv .vars $executive && chmod +x $executive
		rm ./_*; rm vars functions
		[ $? -eq 0 ] && _special
}


# "Compile"
# Checks to see if "native" files still exsist, if so, "merges" all files together in a certain order, then cleans up the place.
_compile()
{
		all_files=( $(ls .) )
		for n_file in ${all_files[@]}
		do case "$n_file" in
				vars) _vars; _returns ;;
				functions) _functions; _returns ;;
		esac done
		[ $? -eq 0 ] && { _sweep; } || return 1
}

# Options
QUIET=0
editor=vim

#options=$(getopt -o 'd::fn:v' -l 'new,del,vars' -- "$@")
#[ $? -gt 0 ] && exit 1
#eval set -- "$options"

if [ $# -eq 0 ];
then
		_usage
else
		case "$1" in
				new) shift; _setup "$@" ;;
				del) shift; _remove "$@" ;;
				lf) shift; _list_functions ;;
				lv) shift; _list_vars ;;
				-s|--silent) shift; QUIET='1' ;;
				-h|--help_) shift; _usage ;;
				-v|--ver) _version ;;
		esac
fi

