#!/bin/bash

#executive=""
readonly rawman=${executive}.1.md
readonly color='\e[32m'
readonly reset='\e[0m'

_version()
{
		echo "$(basename $0) - version $VERSION"
}

_usage()
{
		_version
		echo "
		|Usage:
		|   $(basename $0) [Options]... [Command]
        |
		|Options:
		|   -h, --help     Show usage information
		|   -v, --version  Show version information
		|   -n, --name=    name of the new script
		|   
        |Commands:
        |   new   setup a new working directory
        |   del   delete all working files in directory
        |   make  "compile" all working files\
		" | cut -d "|" -f 2
}

# Uix
_warning(){ [ $QUIET = 0 ] && echo -n -e "${color}[WARNING]${reset} -- ${*}"; }
_exit(){ [ $QUIET = 0 ] && echo -e "${color}[FATAL]${reset} -- ${*}" && exit $EX; }

# Remove all native files
_remove()
{
		_remove_all()
		{
				{ while read -r line; do rm $(cut -d " " -f 2); done < functions; }
				[[ $? -eq 0 ]] && { rm vars functions ${executive}; } || _exit 1
		}
		
		if [[ "$QUIET" == "0" ]]
		then
				# Confirmation required
				echo "CONFIRM [ y | n ]: "
				read conf

				[[ "$conf" == "n" || "N" || "no" || "NO" ]] && return 0
				[[ "$conf" == "y" || "Y" || "yes" || "YES" ]] && _remove_all || _exit 1
		else
				_remove_all || _exit 1
		fi
}

# Setup a new working directory
_setup() 
{
        if [[ $1 == "-n" && $2 ]]; then
            executive=$2
        else
            echo -n "[NAME]: "; read executive
        fi

		# Check if a working setup exists
		if [[ -f functions && -f vars ]]; then
            if [[ QUIET = 0 ]]; then
                _warning "You already appear to to be in a working directory, overwrite?: "
                read over
                if [[ "$over" == 'n' || 'N' ]]; then
                    ex=1; _exit "user aborted action"
                elif [[ "$over" == "y" || "Y" ]]; then
                    rm -rf ./* ; continue
                fi
            fi
        fi

		# Set native files, give an apropriate version number, and open $executive in an editor
        { touch functions vars ${executive}; } #|| ex=1; _exit "data error"
        { echo "readonly VERSION=1.0" > vars; } #|| ex=1; _exit "data error"
        { echo "#!/bin/bash" > "${executive}" && chmod +x "${executive}"; } #|| ex=1; _exit "data error"
        ${EDITOR} ${executive}
}


# Show variable information
_list_vars()
{
	[[ ! -f vars ]] && ex=1; _exit "no variables to list"
    #sed '/^\s*$/d'
    echo -e "${color}VARIABLES:${reset}"
    while read -r line; do 
        case $line in
            ''|\#*) continue ;;
		esac
	    echo "$(echo -e ${color} $(echo $line | cut -d "=" -f 1 | cut -d " " -f 2 ) ${reset})$(echo $line | cut -d "=" -f 2 | sed 's/#.*//')"
	done < vars
}

# Show functions' "order of opertations"
_list_functions()
{
    [[ ! -f functions ]] && ex=1; _exit "no functions to list"
    echo -e "${color}FUNCTIONS:${reset}" && \
        while read -r line; do 
            echo -e " ${color}(${n})${reset}\t$(echo $line | cut -d ' ' -f 2)";
			n=$(($n + 1))
		done < functions | sed '1 d' | sed '$ d'
}


# Native files merged
_vars()
{
		# Start if 'vars' exists
		cat $executive | head -n 1 > .vars && cat vars >> .vars || return 1
}

_functions()
{
		while read line
		do
				cat $(cut -d " " -f 2) > .funcs
		done < functions
		[ $? -ne 0 ] && { return 1; } ||  return 0
}


# Special files handled
self=$(basename $0)
_special()
{
		local found
		for found in ${all_files[@]}
		do
				case "$found" in
						"$rawman") rm "$rawman" || return 1 ;;
						#"$self" ) rm "$self" || return 1 ;;
				esac
		done
}

# Finish him
_sweep()
{
		cat .funcs >> .vars && rm .funcs
		sed -i '1,4 d' $executive
		cat $executive >> .vars && rm $executive
		mv .vars $executive && chmod +x $executive
		rm ./_*; rm vars functions
		[ $? -eq 0 ] && _special
}


# "Compile"
# Checks to see if "native" files still exsist, if so, "merges" all files together in a certain order, then cleans up the place.
_compile()
{
		all_files=( $(ls .) )
		for n_file in ${all_files[@]}
		do case "$n_file" in
				vars) _vars; _returns ;;
				functions) _functions; _returns ;;
		esac done
		[ $? -eq 0 ] && { _sweep; } || return 1
}

# Options
QUIET=0
editor=vim

#options=$(getopt -o 'hsv' -l 'new,del,lf,lv' -- "$@")
#[ $? -gt 0 ] && exit 1
#eval set -- "$options"

if [ $# -eq 0 ];
then
		_usage
else
		case "$1" in
				new) shift; _setup "$@" ;;
				del) _remove; ;;
                ls) _list_vars && _list_functions ;;
                lsf) _list_functions ;;
				lsv) _list_vars ;;
				-s|--silent) QUIET='1'; shift ;;
				-h|--help_) _usage ;;
				-v|--ver) _version ;;
		esac
fi

